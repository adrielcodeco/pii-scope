{"version":3,"sources":["require.js","require.ts"],"names":["Object","defineProperty","exports","value","path","require","util","assert","Module","debug","debuglog","NativeRequire","_recursive","create","_extensions","module","filename","Reflect","set","compile","noCacheFor","undefined","updateChildren","parent","child","scan","children","includes","push","tryModuleLoad","id","loaded","paths","_nodeModulePaths","dirname","extension","extname","makeRequireFunction","mod","Error","ParentModule","constructor","_cache","context","request","msg","_resolveFilename","console","warn","isAbsolute","cachedModule","get","resolve","options","_resolveLookupPaths","requireAny","process","mainModule"],"mappings":"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","file":"require.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path = require(\"path\");\nconst util = require(\"util\");\nconst assert = require(\"assert\");\nconst Module = require('module');\nconst debug = util.debuglog('module');\nconst NativeRequire = require;\nconst _recursive = Object.create(null);\nconst _extensions = Object.create(null);\n_extensions['.js'] = function (module, filename) {\n    Reflect.set(module, 'exports', NativeRequire('./compile').compile(filename, module, module.noCacheFor, undefined));\n};\n_extensions['.json'] = Module._extensions['.json'];\n_extensions['.node'] = Module._extensions['.node'];\nfunction updateChildren(parent, child, scan) {\n    const children = parent && parent.children;\n    if (children && !(scan && children.includes(child)))\n        children.push(child);\n}\nfunction tryModuleLoad(module, filename) {\n    try {\n        debug('load %j for module %j', filename, module.id);\n        assert(!module.loaded);\n        module.filename = filename;\n        module.paths = Module._nodeModulePaths(path.dirname(filename));\n        let extension = path.extname(filename) || '.js';\n        if (!_extensions[extension])\n            extension = '.js';\n        _extensions[extension](module, filename);\n        module.loaded = true;\n    }\n    finally {\n    }\n}\nfunction makeRequireFunction(mod) {\n    if (!mod) {\n        throw new Error('the mod argument is invalid');\n    }\n    const ParentModule = mod.constructor;\n    const _cache = (mod.context || {})._cache || Module._cache;\n    const noCacheFor = mod.noCacheFor || [];\n    function require(request) {\n        try {\n            if (!request) {\n                throw new Error('the path argument is invalid');\n            }\n            let msg = `Recursive module load detected!\\r\\n`;\n            msg += `The \"${request}\" module will be loaded, but this is not a best practice\\r\\n`;\n            msg += `This could be a mistake, check your code and correct`;\n            const filename = Module._resolveFilename(request, mod, false);\n            if (request in _recursive && _recursive[request] === filename) {\n                console.warn(msg);\n                return {};\n            }\n            if (!path.isAbsolute(request) && !noCacheFor.includes(filename)) {\n                const cachedModule = _cache[filename];\n                if (cachedModule) {\n                    if (cachedModule.loaded) {\n                        updateChildren(mod, cachedModule, true);\n                        return cachedModule.exports;\n                    }\n                    else {\n                        console.warn(msg);\n                        _recursive[request] = filename;\n                    }\n                }\n            }\n            const module = new ParentModule(filename, mod);\n            module.noCacheFor = noCacheFor;\n            module.context = mod.context;\n            if (!path.isAbsolute(request) && !noCacheFor.includes(filename)) {\n                _cache[filename] = module;\n            }\n            tryModuleLoad(module, filename);\n            return Reflect.get(module, 'exports');\n        }\n        finally {\n        }\n    }\n    function resolve(request, options) {\n        if (typeof request !== 'string') {\n            throw new Error('The \"request\" argument must be of type \"string\"');\n        }\n        return Module._resolveFilename(request, mod, false, options);\n    }\n    function paths(request) {\n        if (typeof request !== 'string') {\n            throw new Error('The \"request\" argument must be of type \"string\"');\n        }\n        return Module._resolveLookupPaths(request, mod, true);\n    }\n    const requireAny = require;\n    requireAny['resolve'] = resolve;\n    requireAny['paths'] = paths;\n    requireAny['main'] = process.mainModule;\n    requireAny['extensions'] = _extensions;\n    requireAny['cache'] = _cache;\n    return require;\n}\nexports.makeRequireFunction = makeRequireFunction;\n","/**\n * Copyright 2018-present, CODECO. All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as path from 'path'\nimport * as util from 'util'\nimport * as assert from 'assert'\nconst Module = require('module')\n\nconst debug = util.debuglog('module')\nconst NativeRequire = require\nconst _recursive = Object.create(null)\nconst _extensions = Object.create(null)\n\n// Native extension for .js\n_extensions['.js'] = function (module: any, filename: string) {\n  Reflect.set(\n    module,\n    'exports',\n    NativeRequire('./compile').compile(\n      filename,\n      module,\n      module.noCacheFor,\n      undefined\n    )\n  )\n}\n\n// Native extension for .json\n_extensions['.json'] = Module._extensions['.json']\n\n// Native extension for .node\n_extensions['.node'] = Module._extensions['.node']\n\nfunction updateChildren (parent: any, child: any, scan: any) {\n  const children = parent && parent.children\n  if (children && !(scan && children.includes(child))) children.push(child)\n}\n\nfunction tryModuleLoad (module: any, filename: string) {\n  try {\n    debug('load %j for module %j', filename, module.id)\n    assert(!module.loaded)\n    module.filename = filename\n    module.paths = Module._nodeModulePaths(path.dirname(filename))\n\n    let extension = path.extname(filename) || '.js'\n    if (!_extensions[extension]) extension = '.js'\n    _extensions[extension](module, filename)\n    module.loaded = true\n  } finally {\n    // does nothing\n  }\n}\n\nexport function makeRequireFunction (mod: any) {\n  if (!mod) {\n    throw new Error('the mod argument is invalid')\n  }\n  const ParentModule = mod.constructor\n  const _cache = (mod.context || {})._cache || Module._cache\n  const noCacheFor = mod.noCacheFor || []\n\n  function require (request: string) {\n    try {\n      if (!request) {\n        throw new Error('the path argument is invalid')\n      }\n      let msg = `Recursive module load detected!\\r\\n`\n      msg += `The \"${request}\" module will be loaded, but this is not a best practice\\r\\n`\n      msg += `This could be a mistake, check your code and correct`\n      const filename = Module._resolveFilename(request, mod, false)\n      if (request in _recursive && _recursive[request] === filename) {\n        console.warn(msg)\n        return {}\n      }\n      if (!path.isAbsolute(request) && !noCacheFor.includes(filename)) {\n        const cachedModule = _cache[filename]\n        if (cachedModule) {\n          if (cachedModule.loaded) {\n            updateChildren(mod, cachedModule, true)\n            return cachedModule.exports\n          } else {\n            console.warn(msg)\n            _recursive[request] = filename\n          }\n        }\n      }\n      // if (filename === request) {\n      //   return NativeRequire(request)\n      // }\n      const module = new ParentModule(filename, mod)\n      module.noCacheFor = noCacheFor\n      module.context = mod.context\n      if (!path.isAbsolute(request) && !noCacheFor.includes(filename)) {\n        _cache[filename] = module\n      }\n      tryModuleLoad(module, filename)\n      return Reflect.get(module, 'exports')\n    } finally {\n      // does nothing\n    }\n  }\n\n  function resolve (request: string, options: any) {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof request !== 'string') {\n      // throw new ERR_INVALID_ARG_TYPE(\"request\", \"string\", request);\n      throw new Error('The \"request\" argument must be of type \"string\"')\n    }\n    return Module._resolveFilename(request, mod, false, options)\n  }\n\n  function paths (request: string) {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof request !== 'string') {\n      // throw new ERR_INVALID_ARG_TYPE(\"request\", \"string\", request);\n      throw new Error('The \"request\" argument must be of type \"string\"')\n    }\n    return Module._resolveLookupPaths(request, mod, true)\n  }\n\n  const requireAny = require as any\n  requireAny['resolve'] = resolve\n  requireAny['paths'] = paths\n  requireAny['main'] = process.mainModule\n  requireAny['extensions'] = _extensions\n  requireAny['cache'] = _cache\n  return require\n}\n"]}